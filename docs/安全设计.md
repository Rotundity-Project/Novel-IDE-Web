# Novel-Studio-Web 安全设计文档

## 1. 安全概述

### 1.1 安全目标
- 保护用户数据和隐私
- 防止未授权访问
- 防范常见安全漏洞
- 确保 API 安全性
- 保护 AI 调用成本

### 1.2 安全原则
- 最小权限原则
- 深度防御
- 安全默认配置
- 持续监控和审计
- 及时更新和补丁

---

## 2. 认证与授权

### 2.1 认证方案

#### JWT 认证流程
```
1. 用户登录 → 验证凭证
2. 生成 Access Token (15分钟) + Refresh Token (7天)
3. 客户端存储 Access Token (内存/HttpOnly Cookie)
4. 客户端存储 Refresh Token (HttpOnly Cookie)
5. 后续请求携带 Access Token
6. Token 过期 → 使用 Refresh Token 刷新
```

#### Token 配置

```typescript
interface JWTConfig {
  accessTokenSecret: string;
  refreshTokenSecret: string;
  accessTokenExpiresIn: number;      // 15 分钟
  refreshTokenExpiresIn: number;     // 7 天
  issuer: string;
  audience: string;
}

const jwtConfig: JWTConfig = {
  accessTokenSecret: process.env.JWT_ACCESS_SECRET || 'change-me',
  refreshTokenSecret: process.env.JWT_REFRESH_SECRET || 'change-me',
  accessTokenExpiresIn: 900,        // 15 * 60
  refreshTokenExpiresIn: 604800,    // 7 * 24 * 60 * 60
  issuer: 'novel-studio-web',
  audience: 'novel-studio-web-users',
};
```

#### Token 生成与验证

```typescript
import jwt from 'jsonwebtoken';

class AuthService {
  /**
   * 生成 Access Token
   */
  generateAccessToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'access' },
      jwtConfig.accessTokenSecret,
      {
        expiresIn: jwtConfig.accessTokenExpiresIn,
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience,
      }
    );
  }

  /**
   * 生成 Refresh Token
   */
  generateRefreshToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'refresh', jti: this.generateJTI() },
      jwtConfig.refreshTokenSecret,
      {
        expiresIn: jwtConfig.refreshTokenExpiresIn,
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience,
      }
    );
  }

  /**
   * 验证 Access Token
   */
  verifyAccessToken(token: string): { userId: string } {
    try {
      return jwt.verify(token, jwtConfig.accessTokenSecret, {
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience,
      }) as { userId: string };
    } catch (error) {
      throw new Error('Invalid or expired token');
    }
  }

  /**
   * 验证 Refresh Token
   */
  verifyRefreshToken(token: string): { userId: string; jti: string } {
    try {
      return jwt.verify(token, jwtConfig.refreshTokenSecret, {
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience,
      }) as { userId: string; jti: string };
    } catch (error) {
      throw new Error('Invalid or expired refresh token');
    }
  }

  /**
   * 生成唯一 JTI (JWT ID)
   */
  private generateJTI(): string {
    return crypto.randomBytes(16).toString('hex');
  }
}
```

### 2.2 密码安全

#### 密码哈希

```typescript
import bcrypt from 'bcrypt';
import crypto from 'crypto';

class PasswordService {
  private readonly saltRounds = 12;
  private readonly minPasswordLength = 8;
  private readonly maxPasswordLength = 128;

  /**
   * 哈希密码
   */
  async hashPassword(password: string): Promise<string> {
    // 验证密码长度
    if (password.length < this.minPasswordLength) {
      throw new Error('Password too short');
    }
    if (password.length > this.maxPasswordLength) {
      throw new Error('Password too long');
    }

    // 使用 bcrypt 哈希
    return bcrypt.hash(password, this.saltRounds);
  }

  /**
   * 验证密码
   */
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  /**
   * 密码强度检查
   */
  checkPasswordStrength(password: string): PasswordStrength {
    let score = 0;
    const feedback: string[] = [];

    // 长度检查
    if (password.length >= 12) score += 2;
    else if (password.length >= 8) score += 1;
    else feedback.push('密码长度至少 8 位');

    // 复杂性检查
    if (/[a-z]/.test(password)) score += 1;
    else feedback.push('包含小写字母');

    if (/[A-Z]/.test(password)) score += 1;
    else feedback.push('包含大写字母');

    if (/[0-9]/.test(password)) score += 1;
    else feedback.push('包含数字');

    if (/[^a-zA-Z0-9]/.test(password)) score += 1;
    else feedback.push('包含特殊字符');

    // 常见密码检查
    if (this.isCommonPassword(password)) {
      score = 0;
      feedback.push('密码过于常见');
    }

    return { score, max: 6, feedback };
  }

  /**
   * 检查常见密码
   */
  private isCommonPassword(password: string): boolean {
    const commonPasswords = ['password', '123456', 'qwerty', 'admin'];
    return commonPasswords.includes(password.toLowerCase());
  }
}

interface PasswordStrength {
  score: number;
  max: number;
  feedback: string[];
}
```

### 2.3 授权方案

#### 基于 RBAC 的权限控制

```typescript
type Permission =
  | 'work:read'
  | 'work:write'
  | 'work:delete'
  | 'chapter:read'
  | 'chapter:write'
  | 'chapter:delete'
  | 'ai:use'
  | 'ai:configure'
  | 'agent:read'
  | 'agent:create'
  | 'agent:edit';

interface Role {
  name: string;
  permissions: Permission[];
}

const roles: Role[] = [
  {
    name: 'user',
    permissions: [
      'work:read',
      'work:write',
      'chapter:read',
      'chapter:write',
      'ai:use',
      'agent:read',
    ],
  },
  {
    name: 'admin',
    permissions: [
      'work:read',
      'work:write',
      'work:delete',
      'chapter:read',
      'chapter:write',
      'chapter:delete',
      'ai:use',
      'ai:configure',
      'agent:read',
      'agent:create',
      'agent:edit',
    ],
  },
];

class AuthorizationService {
  /**
   * 检查用户权限
   */
  hasPermission(userId: string, permission: Permission): boolean {
    const userRole = this.getUserRole(userId);
    const role = roles.find(r => r.name === userRole);

    return role?.permissions.includes(permission) || false;
  }

  /**
   * 检查资源所有权
   */
  ownsResource(userId: string, resourceType: string, resourceId: string): boolean {
    // 检查用户是否拥有该资源
    return this.checkOwnership(userId, resourceType, resourceId);
  }

  /**
   * 获取用户角色
   */
  private getUserRole(userId: string): string {
    // 从数据库获取用户角色
    return 'user';
  }

  /**
   * 检查所有权
   */
  private checkOwnership(userId: string, resourceType: string, resourceId: string): boolean {
    // 实现资源所有权检查逻辑
    return true;
  }
}
```

#### 资源访问控制中间件

```typescript
import { Request, Response, NextFunction } from 'express';

/**
 * 检查资源所有权
 */
export function requireOwnership(resourceType: string) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.user!.userId;
      const resourceId = req.params.id;

      const authz = new AuthorizationService();

      // 检查所有权或管理员权限
      if (!authz.ownsResource(userId, resourceType, resourceId) &&
          !authz.hasPermission(userId, 'admin')) {
        return res.status(403).json({
          success: false,
          error: {
            code: 'AUTH_003',
            message: '无权访问该资源',
          },
        });
      }

      next();
    } catch (error) {
      res.status(500).json({
        success: false,
        error: {
          code: 'SERVER_ERROR',
          message: '服务器错误',
        },
      });
    }
  };
}
```

---

## 3. 数据安全

### 3.1 数据加密

#### 敏感字段加密

```typescript
import crypto from 'crypto';

class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly key = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex');
  private readonly ivLength = 16;

  /**
   * 加密
   */
  encrypt(text: string): string {
    const iv = crypto.randomBytes(this.ivLength);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    // IV + AuthTag + Encrypted
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  /**
   * 解密
   */
  decrypt(encryptedText: string): string {
    const parts = encryptedText.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const authTag = Buffer.from(parts[1], 'hex');
    const encrypted = parts[2];

    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

### 3.2 数据库安全

#### SQL 注入防护

使用 Prisma ORM，自动进行参数化查询：

```typescript
// 安全的查询
const user = await prisma.user.findUnique({
  where: { id: userId },
});

// 参数化查询
const works = await prisma.work.findMany({
  where: {
    userId: userId,
    title: {
      contains: searchQuery,  // Prisma 自动转义
    },
  },
});
```

#### 行级安全策略（RLS）

```sql
-- 在 PostgreSQL 中启用 RLS
ALTER TABLE works ENABLE ROW LEVEL SECURITY;

-- 用户只能访问自己的作品
CREATE POLICY user_works_access ON works
  FOR ALL
  USING (user_id = current_user_id());

-- 创建函数获取当前用户 ID
CREATE OR REPLACE FUNCTION current_user_id()
RETURNS UUID AS $$
  SELECT NULL::UUID;
$$ LANGUAGE SQL STABLE;
```

### 3.3 敏感数据存储

#### 不存储的内容
- 明文密码
- 完整的 API Key
- 支付信息
- 私人对话内容（除非用户明确保存）

#### 需要加密存储的内容
- 第三方 OAuth Token
- Refresh Token（如果存数据库）
- 用户的个人信息

---

## 4. API 安全

### 4.1 CORS 配置

```typescript
import cors from 'cors';

const corsOptions = {
  origin: (origin: string | undefined, callback: any) => {
    const allowedOrigins = [
      'https://novel-studio-web.com',
      'https://app.novel-studio-web.com',
      'http://localhost:3000',  // 开发环境
    ];

    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400,  // 24 小时
};

app.use(cors(corsOptions));
```

### 4.2 请求验证

#### 输入验证中间件

```typescript
import { body, param, query, validationResult } from 'express-validator';

/**
 * 验证中间件
 */
export const validate = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(422).json({
      success: false,
      error: {
        code: 'VALIDATION_001',
        message: '参数验证失败',
        details: errors.array(),
      },
    });
  }
  next();
};

/**
 * 注册验证
 */
export const registerValidation = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('邮箱格式不正确'),
  body('username')
    .isLength({ min: 3, max: 20 })
    .matches(/^[a-zA-Z0-9_]+$/)
    .withMessage('用户名只能包含字母、数字和下划线'),
  body('password')
    .isLength({ min: 8 })
    .withMessage('密码至少 8 位'),
];

/**
 * 创建作品验证
 */
export const createWorkValidation = [
  body('title')
    .isLength({ min: 1, max: 255 })
    .withMessage('标题长度必须在 1-255 之间'),
  body('description')
    .optional()
    .isLength({ max: 1000 })
    .withMessage('描述最多 1000 字'),
];
```

### 4.3 限流与防刷

#### 请求限流

```typescript
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';

/**
 * 通用 API 限流
 */
const apiLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rate-limit:',
  }),
  windowMs: 60 * 1000,  // 1 分钟
  max: 100,              // 每分钟 100 次请求
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_001',
      message: '请求过于频繁，请稍后再试',
    },
  },
  standardHeaders: true,
  legacyHeaders: false,
});

/**
 * 认证限流
 */
const authLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'auth-rate-limit:',
  }),
  windowMs: 15 * 60 * 1000,  // 15 分钟
  max: 5,                     // 15 分钟内 5 次尝试
  skipSuccessfulRequests: true,
});

/**
 * AI 调用限流
 */
const aiLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'ai-rate-limit:',
  }),
  windowMs: 60 * 1000,  // 1 分钟
  max: 20,              // 每分钟 20 次 AI 调用
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_001',
      message: 'AI 调用过于频繁，请稍后再试',
    },
  },
});

app.use('/api/v1', apiLimiter);
app.use('/api/v1/auth/login', authLimiter);
app.use('/api/v1/auth/register', authLimiter);
app.use('/api/v1/ai', aiLimiter);
```

---

## 5. AI 安全

### 5.1 Prompt 注入防护

#### Prompt 过滤

```typescript
class PromptSecurityService {
  /**
   * 检测恶意 Prompt
   */
  detectMaliciousPrompt(prompt: string): boolean {
    const maliciousPatterns = [
      /ignore previous instructions/i,
      /disregard above/i,
      /forget everything/i,
      /new instruction/i,
      /system:\s*\{/i,
      /<\|.*?\|>/gi,  // 特殊分隔符
      /```.*?```/gs,  // 代码块注入
    ];

    return maliciousPatterns.some(pattern => pattern.test(prompt));
  }

  /**
   * 清理用户输入
   */
  sanitizeUserInput(input: string): string {
    // 移除可能危险的字符
    return input
      .replace(/<\|.*?\|>/g, '')
      .replace(/```[\s\S]*?```/g, '')
      .slice(0, 10000);  // 限制长度
  }

  /**
   * 验证系统提示词（仅管理员可修改）
   */
  validateSystemPrompt(prompt: string, userId: string): boolean {
    // 检查是否为管理员
    if (!this.isAdmin(userId)) {
      return false;
    }

    // 检查长度
    if (prompt.length > 10000) {
      return false;
    }

    return true;
  }

  private isAdmin(userId: string): boolean {
    // 实现管理员检查
    return false;
  }
}
```

### 5.2 内容过滤

#### 输出内容检查

```typescript
class ContentFilterService {
  /**
   * 检查内容是否违规
   */
  async checkContent(content: string): Promise<{ safe: boolean; reason?: string }> {
    // 1. 检查敏感词
    if (this.containsSensitiveWords(content)) {
      return { safe: false, reason: '包含敏感词汇' };
    }

    // 2. 检查个人信息（邮箱、电话等）
    if (this.containsPersonalInfo(content)) {
      return { safe: false, reason: '包含个人信息' };
    }

    // 3. 调用第三方内容审核 API（可选）
    const moderationResult = await this.moderateContent(content);
    if (!moderationResult.safe) {
      return { safe: false, reason: moderationResult.reason };
    }

    return { safe: true };
  }

  private containsSensitiveWords(content: string): boolean {
    const sensitiveWords = ['敏感词1', '敏感词2'];  // 从配置加载
    const lowerContent = content.toLowerCase();

    return sensitiveWords.some(word =>
      lowerContent.includes(word.toLowerCase())
    );
  }

  private containsPersonalInfo(content: string): boolean {
    // 检测邮箱
    if (/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/.test(content)) {
      return true;
    }

    // 检测手机号（中国）
    if (/1[3-9]\d{9}/.test(content)) {
      return true;
    }

    return false;
  }

  private async moderateContent(content: string): Promise<{ safe: boolean; reason?: string }> {
    // 调用 OpenAI Moderation API 或其他审核服务
    try {
      const response = await fetch('https://api.openai.com/v1/moderations', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        },
        body: JSON.stringify({ input: content }),
      });

      const data = await response.json();

      if (data.results[0].flagged) {
        const categories = data.results[0].categories;
        const reasons = Object.entries(categories)
          .filter(([_, flagged]) => flagged)
          .map(([category]) => category)
          .join(', ');

        return { safe: false, reason: `内容违规: ${reasons}` };
      }

      return { safe: true };
    } catch (error) {
      // 失败时默认放行（根据业务需求）
      return { safe: true };
    }
  }
}
```

### 5.3 成本控制

#### Token 使用监控

```typescript
class CostControlService {
  private readonly dailyLimit: number;
  private readonly alertThreshold: number;

  constructor() {
    this.dailyLimit = parseFloat(process.env.DAILY_COST_LIMIT || '10');
    this.alertThreshold = parseFloat(process.env.COST_ALERT_THRESHOLD || '0.8');
  }

  /**
   * 检查成本限制
   */
  async checkCostLimit(userId: string): Promise<{ allowed: boolean; reason?: string }> {
    const todayCost = await this.getTodayCost(userId);
    const alertCost = this.dailyLimit * this.alertThreshold;

    if (todayCost >= this.dailyLimit) {
      return { allowed: false, reason: '今日 AI 调用成本已达上限' };
    }

    if (todayCost >= alertCost) {
      // 发送警告通知
      await this.sendAlert(userId, todayCost, this.dailyLimit);
    }

    return { allowed: true };
  }

  /**
   * 记录成本
   */
  async recordCost(
    userId: string,
    modelId: string,
    inputTokens: number,
    outputTokens: number
  ): Promise<number> {
    const cost = this.calculateCost(modelId, inputTokens, outputTokens);

    // 存储到数据库
    await prisma.aiUsageStats.upsert({
      where: {
        userId_statDate: {
          userId,
          statDate: new Date(),
        },
      },
      update: {
        totalCost: { increment: cost },
        totalInputTokens: { increment: inputTokens },
        totalOutputTokens: { increment: outputTokens },
        totalRequests: { increment: 1 },
      },
      create: {
        userId,
        statDate: new Date(),
        totalCost: cost,
        totalInputTokens: inputTokens,
        totalOutputTokens: outputTokens,
        totalRequests: 1,
      },
    });

    return cost;
  }

  private async getTodayCost(userId: string): Promise<number> {
    const stats = await prisma.aiUsageStats.findUnique({
      where: {
        userId_statDate: {
          userId,
          statDate: new Date(),
        },
      },
    });

    return stats?.totalCost || 0;
  }

  private calculateCost(
    modelId: string,
    inputTokens: number,
    outputTokens: number
  ): number {
    // 从模型配置获取定价
    const pricing = this.getModelPricing(modelId);
    const inputCost = (inputTokens / 1000) * pricing.input;
    const outputCost = (outputTokens / 1000) * pricing.output;

    return inputCost + outputCost;
  }

  private getModelPricing(modelId: string): { input: number; output: number } {
    // 从配置或数据库获取
    return { input: 0.01, output: 0.03 };
  }

  private async sendAlert(userId: string, currentCost: number, limit: number) {
    // 发送成本预警通知
    await prisma.notification.create({
      data: {
        userId,
        type: 'warning',
        title: 'AI 成本预警',
        content: `今日 AI 调用成本已达到 $${currentCost.toFixed(2)}（上限 $${limit.toFixed(2)}）`,
      },
    });
  }
}
```

---

## 6. 传输安全

### 6.1 HTTPS 配置

```typescript
// 生产环境强制 HTTPS
if (process.env.NODE_ENV === 'production') {
  app.use((req, res, next) => {
    if (!req.secure) {
      return res.redirect(301, `https://${req.headers.host}${req.url}`);
    }
    next();
  });
}
```

### 6.2 安全响应头

```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'", 'wss:'],
    },
  },
  hsts: {
    maxAge: 31536000,  // 1 年
    includeSubDomains: true,
    preload: true,
  },
  noSniff: true,
  xssFilter: true,
  referrerPolicy: { policy: 'same-origin' },
}));

// 自定义安全头
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  next();
});
```

---

## 7. 安全日志与审计

### 7.1 安全事件日志

```typescript
class SecurityAuditLogger {
  /**
   * 记录安全事件
   */
  async logEvent(event: SecurityEvent) {
    await prisma.securityLog.create({
      data: {
        eventType: event.type,
        severity: event.severity,
        userId: event.userId,
        ip: event.ip,
        userAgent: event.userAgent,
        details: event.details,
      },
    });

    // 高危事件立即通知
    if (event.severity === 'high') {
      await this.notifySecurityTeam(event);
    }
  }

  /**
   * 检测可疑活动
   */
  async detectSuspiciousActivity(userId: string): Promise<boolean> {
    // 检查短时间内多次失败登录
    const recentFailures = await prisma.securityLog.count({
      where: {
        eventType: 'login_failed',
        userId,
        timestamp: {
          gte: new Date(Date.now() - 15 * 60 * 1000),  // 15 分钟内
        },
      },
    });

    if (recentFailures >= 5) {
      await this.logEvent({
        type: 'suspicious_activity',
        severity: 'high',
        userId,
        details: { reason: 'Multiple failed login attempts' },
      });
      return true;
    }

    return false;
  }

  private async notifySecurityTeam(event: SecurityEvent) {
    // 发送邮件、Slack 或其他通知
  }
}

interface SecurityEvent {
  type: string;
  severity: 'low' | 'medium' | 'high';
  userId?: string;
  ip?: string;
  userAgent?: string;
  details?: Record<string, any>;
}
```

---

## 8. 定期安全检查

### 8.1 安全检查清单

- [ ] 定期更新依赖包（每周）
- [ ] 运行安全扫描（npm audit, Snyk）
- [ ] 检查数据库访问日志
- [ ] 审查 API 访问模式
- [ ] 监控异常登录行为
- [ ] 测试备份和恢复流程
- [ ] 进行渗透测试（季度）

### 8.2 安全更新流程

1. 监控安全公告（CVE、供应商公告）
2. 评估影响和优先级
3. 在测试环境验证修复
4. 安排维护窗口
5. 应用更新
6. 验证功能正常

---

**文档版本**: v1.0
**最后更新**: 2026-02-11
