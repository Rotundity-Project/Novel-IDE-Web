# Novel-IDE-Web 性能优化文档

## 1. 性能目标

| 指标 | 目标值 |
|------|--------|
| 首屏加载时间 (FCP) | < 1.5s |
| 可交互时间 (TTI) | < 3s |
| 页面完全加载 (LCP) | < 2.5s |
| API 响应时间 (P95) | < 200ms |
| 编辑器输入延迟 | < 50ms |
| AI 流式输出延迟 | < 100ms |

---

## 2. 前端性能优化

### 2.1 代码分割

#### 路由级别代码分割

```typescript
// router/routes.tsx
import { lazy } from 'react';

const EditorPage = lazy(() => import('../pages/editor/EditorPage'));
const WorksPage = lazy(() => import('../pages/works/WorksPagePage'));
const AgentsPage = lazy(() => import('../pages/agents/AgentsPage'));

// React Suspense 处理加载状态
<Suspense fallback={<Loading />}>
  <EditorPage />
</Suspense>
```

#### 组件级别代码分割

```typescript
import { lazy } from 'react';

const HeavyChart = lazy(() => import('./components/HeavyChart'));

function Dashboard() {
  return (
    <div>
      <OtherComponents />
      <Suspense fallback={<ChartSkeleton />}>
        <HeavyChart data={data} />
      </Suspense>
    </div>
  );
}
```

### 2.2 懒加载

#### 图片懒加载

```typescript
<img
  src={imageUrl}
  loading="lazy"
  alt="description"
  decoding="async"
/>
```

#### 虚拟滚动

```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

function ChapterList({ chapters }: Props) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: chapters.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 60, // 每个章节的高度
  });

  return (
    <div ref={parentRef} style={{ height: '600px', overflow: 'auto' }}>
      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <ChapterItem
            key={virtualItem.key}
            chapter={chapters[virtualItem.index]}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              transform: `translateY(${virtualItem.start}px)`,
            }}
          />
        ))}
      </div>
    </div>
  );
}
```

### 2.3 缓存策略

#### HTTP 缓存

```typescript
// Service Worker 缓存
const CACHE_NAME = 'novel-ide-v1';
const urlsToCache = [
  '/',
  '/static/main.js',
  '/static/main.css',
  '/fonts/font.woff2',
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

#### React Query 缓存

```typescript
import { QueryClient } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,  // 5 分钟
      cacheTime: 10 * 60 * 1000, // 10 分钟
      refetchOnWindowFocus: false,
    },
  },
});
```

#### 本地存储缓存

```typescript
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: T) => {
    setStoredValue(value);
    window.localStorage.setItem(key, JSON.stringify(value));
  };

  return [storedValue, setValue] as const;
}
```

### 2.4 编辑器优化

#### CodeMirror 优化配置

```typescript
import { EditorView, basicSetup } from 'codemirror';
import { EditorState } from '@codemirror/state';

const view = new EditorView({
  state: EditorState.create({
    doc: content,
    extensions: [
      basicSetup,
      // 禁用语法高亮以提升性能（大文档时）
      EditorView.theme({
        '&': { fontSize: '16px' },
      }),
      // 虚拟滚动
      EditorView.scrollHandler.of((view, range) => {
        // 自定义滚动逻辑
      }),
    ],
  }),
  parent: container,
});
```

#### 防抖输入

```typescript
import { useMemo, useEffect } from 'react';

function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// 使用
const debouncedContent = useDebounce(content, 1000);

// 自动保存
useEffect(() => {
  saveContent(debouncedContent);
}, [debouncedContent]);
```

### 2.5 资源优化

#### 图片优化

```typescript
// 使用 WebP 格式
<picture>
  <source srcSet="image.webp" type="image/webp" />
  <img src="image.jpg" alt="description" loading="lazy" />
</picture>

// 响应式图片
<img
  srcSet="image-320w.jpg 320w,
          image-640w.jpg 640w,
          image-1024w.jpg 1024w"
  sizes="(max-width: 640px) 320px,
         (max-width: 1024px) 640px,
         1024px"
  src="image-1024w.jpg"
  alt="description"
/>
```

#### 字体优化

```css
/* font-display 策略 */
@font-face {
  font-family: 'Inter';
  src: url('/fonts/inter.woff2') format('woff2');
  font-display: swap; /* 立即使用后备字体 */
}

/* 字体子集化 */
@font-face {
  font-family: 'Chinese-Subset';
  src: url('/fonts/chinese-subset.woff2') format('woff2');
  unicode-range: U+4E00-9FFF; /* 仅中文字符 */
}
```

#### CDN 加速

```typescript
// 配置 Vite 使用 CDN
export default defineConfig({
  build: {
    rollupOptions: {
      external: ['react', 'react-dom'],
      output: {
        globals: {
          react: 'React',
          'react-dom': 'ReactDOM',
        },
      },
    },
  },
});
```

---

## 3. 后端性能优化

### 3.1 数据库优化

#### 索引优化

```sql
-- 为常用查询创建索引
CREATE INDEX idx_chapters_work ON chapters(work_id);
CREATE INDEX idx_chapters_order ON chapters(work_id, order_index);

-- 复合索引
CREATE INDEX idx_ai_requests_user_date ON ai_requests(user_id, created_at DESC);

-- 部分索引（只索引活跃数据）
CREATE INDEX idx_active_users ON users(id) WHERE is_active = true;
```

#### 查询优化

```typescript
// ✅ 使用选择查询
const user = await prisma.user.findUnique({
  where: { id: userId },
  select: { id: true, name: true, email: true }, // 只选择需要的字段
});

// ✅ 使用分页
const chapters = await prisma.chapter.findMany({
  where: { workId },
  take: 20,
  skip: (page - 1) * 20,
});

// ✅ 使用关联查询（避免 N+1）
const workWithChapters = await prisma.work.findUnique({
  where: { id: workId },
  include: {
    chapters: {
      take: 10,
      orderBy: { orderIndex: 'asc' },
    },
  },
});
```

#### 批量操作

```typescript
// ✅ 批量插入
await prisma.chapter.createMany({
  data: chapterDataArray,
  skipDuplicates: true,
});

// ✅ 批量更新
await prisma.chapter.updateMany({
  where: { workId },
  data: { status: 'published' },
});
```

### 3.2 缓存优化

#### Redis 缓存

```typescript
class CacheService {
  async get<T>(key: string): Promise<T | null> {
    const cached = await redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    await redis.setex(key, ttl, JSON.stringify(value));
  }

  async del(key: string): Promise<void> {
    await redis.del(key);
  }

  async invalidatePattern(pattern: string): Promise<void> {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }
}

// 使用
const cache = new CacheService();

async function getUser(userId: string): Promise<User> {
  const cacheKey = `user:${userId}`;

  // 先查缓存
  const cached = await cache.get<User>(cacheKey);
  if (cached) return cached;

  // 查数据库
  const user = await prisma.user.findUnique({ where: { id: userId } });

  // 存缓存
  if (user) {
    await cache.set(cacheKey, user, 3600);
  }

  return user!;
}
```

#### 缓存失效策略

```typescript
// 写时失效（Write-through）
async function updateChapter(chapterId: string, data: UpdateChapterDto) {
  const updated = await prisma.chapter.update({
    where: { id: chapterId },
    data,
  });

  // 立即失效相关缓存
  await cache.del(`chapter:${chapterId}`);
  await cache.invalidatePattern(`chapters:${updated.workId}:*`);

  return updated;
}

// 延迟双删（防止缓存不一致）
async function updateChapterDoubleDelete(chapterId: string, data: UpdateChapterDto) {
  // 第一次删除
  await cache.del(`chapter:${chapterId}`);

  // 更新数据库
  const updated = await prisma.chapter.update({
    where: { id: chapterId },
    data,
  });

  // 延迟第二次删除
  setTimeout(() => cache.del(`chapter:${chapterId}`), 1000);

  return updated;
}
```

### 3.3 API 优化

#### 响应压缩

```typescript
import compression from 'compression';

app.use(compression({
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  },
  threshold: 1024, // 只压缩大于 1KB 的响应
}));
```

#### 响应字段选择

```typescript
// GraphQL 风格的字段选择（可选）
app.get('/api/v1/works/:id', async (req, res) => {
  const { fields } = req.query;

  const select = fields ? parseFields(fields as string) : undefined;

  const work = await prisma.work.findUnique({
    where: { id: req.params.id },
    select,
  });

  res.json(work);
});
```

#### 批量请求

```typescript
// GraphQL 风格的批量查询
app.post('/api/v1/batch', async (req, res) => {
  const { requests } = req.body;

  const results = await Promise.all(
    requests.map(({ query, variables }) => {
      return executeQuery(query, variables);
    })
  );

  res.json({ results });
});
```

---

## 4. AI 性能优化

### 4.1 请求优化

#### Token 优化

```typescript
class AIContextOptimizer {
  /**
   * 压缩上下文
   */
  compressContext(context: string, maxTokens: number): string {
    const currentTokens = countTokens(context);

    if (currentTokens <= maxTokens) {
      return context;
    }

    // 移除冗余信息
    let compressed = this.removeRedundancy(context);

    // 截断到合适长度
    if (countTokens(compressed) > maxTokens) {
      compressed = this.truncateToTokens(compressed, maxTokens);
    }

    return compressed;
  }

  /**
   * 移除冗余
   */
  private removeRedundancy(text: string): string {
    return text
      .replace(/\n{3,}/g, '\n\n') // 多个换行压缩为两个
      .replace(/\s{2,}/g, ' ') // 多个空格压缩为一个
      .trim();
  }

  /**
   * 截断到指定 tokens
   */
  private truncateToTokens(text: string, maxTokens: number): string {
    const estimatedLength = maxTokens * 4; // 估算：1 token ≈ 4 字符
    return text.slice(-estimatedLength);
  }
}
```

#### 请求合并

```typescript
class AIRequestBatcher {
  private queue: Array<{
    request: AIRequest;
    resolve: (result: AIResponse) => void;
  }> = [];

  private timer: NodeJS.Timeout | null = null;

  async batch(request: AIRequest): Promise<AIResponse> {
    return new Promise((resolve) => {
      this.queue.push({ request, resolve });

      if (!this.timer) {
        this.timer = setTimeout(() => this.flush(), 100);
      }
    });
  }

  private async flush() {
    if (this.queue.length === 0) return;

    const batch = this.queue.splice(0);
    this.timer = null;

    // 批量处理（如果 API 支持）
    const results = await Promise.all(
      batch.map(({ request }) => this.processRequest(request))
    );

    batch.forEach(({ resolve }, index) => {
      resolve(results[index]);
    });
  }

  private async processRequest(request: AIRequest): Promise<AIResponse> {
    // 处理单个请求
    return aiService.generate(request);
  }
}
```

### 4.2 流式输出优化

#### 增量渲染

```typescript
function useAIStream(agentId: string, prompt: string) {
  const [output, setOutput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);

  useEffect(() => {
    setIsStreaming(true);

    const ws = new WebSocket('ws://localhost:3001/ws');
    let fullContent = '';

    ws.onmessage = (event) => {
      const { chunk, isComplete } = JSON.parse(event.data);

      // 增量更新
      fullContent += chunk;
      setOutput(fullContent);

      if (isComplete) {
        setIsStreaming(false);
        ws.close();
      }
    };

    ws.onerror = () => {
      setIsStreaming(false);
    };

    return () => ws.close();
  }, [agentId, prompt]);

  return { output, isStreaming };
}
```

---

## 5. 性能监控

### 5.1 前端监控

#### Performance API

```typescript
// 收集性能指标
function collectPerformanceMetrics() {
  const perfData = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;

  return {
    // 加载性能
    domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
    loadComplete: perfData.loadEventEnd - perfData.loadEventStart,

    // 关键指标
    firstPaint: perfData.responseStart - perfData.fetchStart,
    firstContentfulPaint: perfData.responseEnd - perfData.requestStart,

    // 资源
    resources: performance.getEntriesByType('resource').map((r) => ({
      name: r.name,
      duration: r.duration,
      size: r.transferSize,
    })),
  };
}

// 上报到监控服务
function reportPerformance() {
  const metrics = collectPerformanceMetrics();

  fetch('/api/v1/telemetry/performance', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(metrics),
  });
}

// 页面加载完成后上报
window.addEventListener('load', () => {
  setTimeout(reportPerformance, 1000);
});
```

#### Core Web Vitals

```typescript
import { getCLS, getFID, getLCP, getFCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric: any) {
  fetch('/api/v1/telemetry/web-vitals', {
    method: 'POST',
    body: JSON.stringify(metric),
  });
}

// 核心 Web 指标
getCLS(sendToAnalytics);   // 累积布局偏移
getFID(sendToAnalytics);   // 首次输入延迟
getLCP(sendToAnalytics);   // 最大内容绘制
getFCP(sendToAnalytics);   // 首次内容绘制
getTTFB(sendToAnalytics); // 首字节时间
```

### 5.2 后端监控

#### 请求监控

```typescript
import { performance } from 'perf_hooks';

app.use((req, res, next) => {
  const start = performance.now();

  res.on('finish', () => {
    const duration = performance.now() - start;

    // 记录请求性能
    logger.info('Request', {
      method: req.method,
      path: req.path,
      status: res.statusCode,
      duration: duration.toFixed(2),
    });

    // 上报到监控
    metrics.recordRequest({
      method: req.method,
      path: req.path,
      status: res.statusCode,
      duration,
    });
  });

  next();
});
```

#### 数据库监控

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' },
    { level: 'error', emit: 'stdout' },
  ],
});

prisma.$on('query', (e) => {
  // 记录慢查询
  if (e.duration > 1000) {
    logger.warn('Slow query', {
      query: e.query,
      duration: e.duration,
      params: e.params,
    });
  }
});
```

---

## 6. 性能测试

### 6.1 负载测试

```typescript
// 使用 k6 进行负载测试
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '30s', target: 100 },  // 逐步增加到 100 用户
    { duration: '1m', target: 100 },   // 保持 100 用户
    { duration: '30s', target: 0 },   // 逐步减少
  ],
  thresholds: {
    http_req_duration: ['p(95)<200'], // 95% 的请求 < 200ms
    http_req_failed: ['rate<0.01'],   // 错误率 < 1%
  },
};

export default function () {
  const res = http.get('http://localhost:3001/api/v1/works');

  check(res, {
    'status was 200': (r) => r.status === 200,
  });

  sleep(1);
}
```

### 6.2 性能基准测试

```typescript
import { performance } from 'perf_hooks';

async function benchmark(fn: () => Promise<any>, iterations: number = 100) {
  const times: number[] = [];

  for (let i = 0; i < iterations; i++) {
    const start = performance.now();
    await fn();
    const end = performance.now();
    times.push(end - start);
  }

  const avg = times.reduce((a, b) => a + b) / times.length;
  const min = Math.min(...times);
  const max = Math.max(...times);

  return { avg, min, max, times };
}

// 使用
const result = await benchmark(() => getUserById('1'));
console.log('Average:', result.avg);
```

---

**文档版本**: v1.0
**最后更新**: 2026-02-11
